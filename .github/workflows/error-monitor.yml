name: Real-time Error Monitoring


# In a production setup, this logic would be implemented as a sidecar monitoring service or integrated into OpenShift‚Äôs native monitoring stack (Prometheus/Grafana). This pipeline simulates real time observability in resource constrained environments.

on:
  workflow_run:
    workflows: ["Spring Boot CD to OpenShift"]
    types:
      - completed
    branches:
      - main

jobs:
  monitor-errors:
    name: Monitor All Services
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    
    steps:
      - name: Install OpenShift CLI
        run: |
          echo "üì• Installing OpenShift CLI..."
          curl -L https://mirror.openshift.com/pub/openshift-v4/clients/oc/latest/linux/oc.tar.gz -o oc.tar.gz
          tar -xzf oc.tar.gz
          sudo mv oc /usr/local/bin/
          sudo chmod +x /usr/local/bin/oc
      
      - name: Log in to OpenShift
        uses: redhat-actions/oc-login@v1
        with:
          openshift_server_url: ${{ secrets.OPENSHIFT_SERVER_URL }}
          openshift_token: ${{ secrets.OPENSHIFT_TOKEN }}
          namespace: ${{ secrets.OPENSHIFT_PROJECT }}

      - name: Monitor All Services
        run: |
          echo "üëÄ Starting multi-service monitoring..."
          
          # Define services to monitor with their specific error patterns
          declare -A SERVICES=(
            ["spring-boot-app"]="error|exception|crash|failure|failed"
            ["mysql"]="ERROR|FATAL|DEADLOCK|CONNECTION|TIMEOUT"
          )
          
          # Monitor duration
          MONITOR_DURATION=1800  # 30 minutes in seconds
          END_TIME=$(($(date +%s) + MONITOR_DURATION))
          
          # Monitor each service
          for SERVICE_NAME in "${!SERVICES[@]}"; do
            echo "üîç Looking for $SERVICE_NAME pods..."
            POD_NAME=$(oc get pods -l app=$SERVICE_NAME --no-headers -o custom-columns=":metadata.name" | head -n 1)
            
            if [ ! -z "$POD_NAME" ]; then
              echo "üì° Monitoring $SERVICE_NAME pod: $POD_NAME"
              
              # Initialize counters for this service
              declare -A ERROR_COUNT_${SERVICE_NAME}=([count]=0)
              LAST_NOTIFICATION_${SERVICE_NAME}=$(date +%s)
              
              # Start monitoring in background
              oc logs -f $POD_NAME | while read line; do
                NOW=$(date +%s)
                
                # Stop if we've reached the time limit
                if [ $NOW -gt $END_TIME ]; then
                  echo "‚úÖ Monitoring period completed for $SERVICE_NAME"
                  break
                fi
                
                # Check for service-specific errors
                if echo "$line" | grep -iE "${SERVICES[$SERVICE_NAME]}" > /dev/null; then
                  # Increment error count
                  eval "ERROR_COUNT_${SERVICE_NAME}[count]=\$((ERROR_COUNT_${SERVICE_NAME}[count] + 1))"
                  echo "‚ö†Ô∏è Error detected in $SERVICE_NAME: $line"
                  
                  # Get current error count
                  eval "current_count=\${ERROR_COUNT_${SERVICE_NAME}[count]}"
                  
                  # Only notify if it's been more than 5 minutes
                  eval "last_notif=\$LAST_NOTIFICATION_${SERVICE_NAME}"
                  if [ $((NOW - last_notif)) -gt 300 ]; then
                    eval "LAST_NOTIFICATION_${SERVICE_NAME}=$NOW"
                    
                    # Get service status and resources
                    POD_STATUS=$(oc get pod $POD_NAME -o jsonpath='{.status.phase}')
                    RESTARTS=$(oc get pod $POD_NAME -o jsonpath='{.status.containerStatuses[0].restartCount}')
                    
                    # Get resource usage (different commands for different services)
                    if [ "$SERVICE_NAME" == "spring-boot-app" ]; then
                      CPU=$(oc exec $POD_NAME -- top -bn1 | grep "Cpu(s)" | awk '{print $2}' || echo "N/A")
                      MEMORY=$(oc exec $POD_NAME -- free -m | grep "Mem:" | awk '{print int($3/$2 * 100)}' || echo "N/A")
                    elif [ "$SERVICE_NAME" == "mysql" ]; then
                      CPU=$(oc exec $POD_NAME -- mysqladmin status | grep "CPU usage" | awk '{print $4}' || echo "N/A")
                      MEMORY=$(oc exec $POD_NAME -- mysqladmin status | grep "Memory usage" | awk '{print $4}' || echo "N/A")
                    fi
                    
                    # Send to Discord with context
                    curl -H "Content-Type: application/json" \
                         -X POST \
                         -d '{
                           "username": "Error Monitor",
                           "embeds": [{
                             "title": "‚ö†Ô∏è Error Detected in '"$SERVICE_NAME"'",
                             "description": "**Error Message:**\n```\n'"$line"'\n```\n\n**Context:**\n‚Ä¢ Service: `'"$SERVICE_NAME"'`\n‚Ä¢ Pod: `'"$POD_NAME"'`\n‚Ä¢ Status: `'"$POD_STATUS"'`\n‚Ä¢ Restarts: `'"$RESTARTS"'`\n‚Ä¢ CPU Usage: `'"$CPU"'%`\n‚Ä¢ Memory Usage: `'"$MEMORY"'%`\n‚Ä¢ Error Count: `'"$current_count"'`\n\n**Time:** `'"$(date -u "+%Y-%m-%d %H:%M:%S UTC")"'`",
                             "color": 15158332
                           }]
                         }' \
                         "${{ secrets.DISCORD_WEBHOOK_URL }}"
                  fi
                fi
              done &
            else
              echo "‚ö†Ô∏è No pods found for $SERVICE_NAME"
            fi
          done
          
          # Wait for all monitoring to complete
          wait
          
          # Print summary
          echo "üìä Monitoring Summary:"
          for SERVICE_NAME in "${!SERVICES[@]}"; do
            eval "count=\${ERROR_COUNT_${SERVICE_NAME}[count]:-0}"
            echo "‚Ä¢ $SERVICE_NAME errors: $count"
          done