name: Spring Boot CD to OpenShift

# Watches your CI pipeline named "Spring Boot CI"

# Triggers automatically when CI completes successfully on main branch

# This creates the CI ‚Üí CD chain

on:
  workflow_run:
    workflows: ["Spring Boot CI"]
    types:
      - completed
    branches:
      - main

jobs:
  deploy-to-openshift:
    name: Deploy to OpenShift
    runs-on: ubuntu-latest
    environment: production

# Gets your OpenShift YAML files from repository
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install OpenShift CLI (oc)
        run: |
          echo "üì• Installing OpenShift CLI..."
          # Download and install oc CLI
          curl -L https://mirror.openshift.com/pub/openshift-v4/clients/oc/latest/linux/oc.tar.gz -o oc.tar.gz
          tar -xzf oc.tar.gz
          sudo mv oc /usr/local/bin/
          sudo chmod +x /usr/local/bin/oc
          echo "‚úÖ OpenShift CLI installed"
          # Verify installation
          oc version --client

# Authenticates with OpenShift cluster using secrets
      - name: Log in to OpenShift
        uses: redhat-actions/oc-login@v1
        with:
          openshift_server_url: ${{ secrets.OPENSHIFT_SERVER_URL }}
          openshift_token: ${{ secrets.OPENSHIFT_TOKEN }}
          namespace: ${{ secrets.OPENSHIFT_PROJECT }}

      # --- 1. Create Secrets for Both MySQL and Spring Boot ---
      - name: Create MySQL Secrets
        run: |
          if ! oc get secret mysql-root-secret >/dev/null 2>&1; then
            echo "üîê Creating MySQL root secret..."
            oc create secret generic mysql-root-secret \
              --from-literal=MYSQL_ROOT_PASSWORD=${{ secrets.MYSQL_ROOT_PASSWORD }} \
              --from-literal=MYSQL_DATABASE=spring_artifacts
          else
            echo "‚úÖ MySQL root secret already exists"
          fi

          if ! oc get secret mysql-secret >/dev/null 2>&1; then
            echo "üîê Creating MySQL application secret..."
            oc create secret generic mysql-secret \
              --from-literal=SPRING_DATASOURCE_URL=jdbc:mysql://mysql:3306/spring_artifacts?createDatabaseIfNotExist=true \
              --from-literal=SPRING_DATASOURCE_USERNAME=${{ secrets.MYSQL_USERNAME }} \
              --from-literal=SPRING_DATASOURCE_PASSWORD=${{ secrets.MYSQL_PASSWORD }} \
              --from-literal=SERVER_PORT=8081
          else
            echo "‚úÖ MySQL application secret already exists"
          fi

          echo "üîç Verifying MySQL Setup..."
          MYSQL_POD=$(oc get pods -l app=mysql -o name | head -n1)
          if [ ! -z "$MYSQL_POD" ]; then
            echo "1. Creating database if not exists..."
            oc exec $MYSQL_POD -- mysql -uroot -p${{ secrets.MYSQL_ROOT_PASSWORD }} -e "CREATE DATABASE IF NOT EXISTS spring_artifacts;"
            
            echo "2. Creating/updating application user..."
            oc exec $MYSQL_POD -- mysql -uroot -p${{ secrets.MYSQL_ROOT_PASSWORD }} -e "
              CREATE USER IF NOT EXISTS '${{ secrets.MYSQL_USERNAME }}'@'%' IDENTIFIED BY '${{ secrets.MYSQL_PASSWORD }}';
              GRANT ALL PRIVILEGES ON spring_artifacts.* TO '${{ secrets.MYSQL_USERNAME }}'@'%';
              FLUSH PRIVILEGES;"
            
            echo "3. Verifying database access..."
            oc exec $MYSQL_POD -- mysql -u${{ secrets.MYSQL_USERNAME }} -p${{ secrets.MYSQL_PASSWORD }} -e "USE spring_artifacts; SHOW TABLES;"
          fi

      # --- 2. Deploy MySQL Database and Create Route for Spring Boot ---
        # Deploy MySQL database if it doesn't exist
        # Create route for Spring Boot if it doesn't exist
        # Set environment variables for Spring Boot
        # Deploy Spring Boot application if it doesn't exist
        # Wait for rollout to complete
        # Verify deployment
        # Send Discord notification
      - name: Ensure MySQL is Running
        run: |
          echo "üîç Checking MySQL status..."
          if [ "$(oc get dc/mysql -o jsonpath='{.spec.replicas}')" -eq 0 ]; then
            echo "‚ö†Ô∏è MySQL is scaled down, scaling up..."
            oc scale dc/mysql --replicas=1
            echo "‚è≥ Waiting for MySQL to be ready..."
            oc wait --for=condition=ready pod -l app=mysql --timeout=300s
            
            # Verify MySQL is responding
            echo "üîç Verifying MySQL connection..."
            MYSQL_POD=$(oc get pods -l app=mysql -o name | head -n1)
            if [ ! -z "$MYSQL_POD" ]; then
              echo "Testing database connection..."
              # Wait a bit for MySQL to be fully ready
              sleep 10
              
              echo "Testing MySQL connection..."
              oc exec $MYSQL_POD -- mysql \
                -h127.0.0.1 \
                -u${{ secrets.MYSQL_USERNAME }} \
                -p${{ secrets.MYSQL_PASSWORD }} \
                -e "SELECT 1;" spring_artifacts
              
              if [ $? -eq 0 ]; then
                echo "‚úÖ MySQL connection successful"
              else
                echo "‚ùå MySQL connection failed"
                echo "üìã Checking MySQL logs..."
                oc logs $MYSQL_POD
                exit 1
              fi
            fi
          else
            echo "‚úÖ MySQL is already running"
          fi

      - name: Bootstrap Environment
        run: |
          if ! oc get dc/mysql >/dev/null 2>&1; then
            echo "üîß Deploying MySQL database..."
            
            # Create PVC first
            oc apply -f openshift/mysql/mysql-pvc.yaml
            
            # Apply MySQL deployment and wait for it to be ready
            oc apply -f openshift/mysql/mysql-deployment.yaml
            echo "‚è≥ Waiting for MySQL deployment to be ready..."
            oc rollout status dc/mysql --timeout=300s
            
            # Create MySQL service
            oc apply -f openshift/mysql/mysql-service.yaml
            
            echo "‚è≥ Waiting for MySQL pod to be ready..."
            # Wait for pod with correct label to be ready
            oc wait --for=condition=ready pod -l app=mysql --timeout=300s || {
              echo "‚ùå Failed waiting for MySQL pod. Checking pod status..."
              oc get pods -l app=mysql
              oc describe pods -l app=mysql
              exit 1
            }
            
            echo "‚úÖ MySQL is ready"
          else
            echo "‚úÖ MySQL already deployed"
            
            # Ensure the deployment is rolled out
            echo "‚è≥ Checking MySQL deployment status..."
            oc rollout status dc/mysql --timeout=300s
          fi

          if ! oc get route spring-boot-route >/dev/null 2>&1; then
            echo "üîß Creating Spring Boot services..."
            oc apply -f openshift/spring-boot-service.yaml
            oc apply -f openshift/spring-boot-route.yaml
            echo "‚úÖ Spring Boot services created"
          else
            echo "‚úÖ Spring Boot services already exist"
          fi

      # --- 3. Deploy Spring Boot Application ---
      - name: Deploy Spring Boot Application
        run: |
          COMMIT_SHA="${{ github.event.workflow_run.head_sha }}"
          # Use full image name with registry
          IMAGE_NAME="${{ secrets.DOCKER_REGISTRY_URL }}/${{ secrets.DOCKER_USERNAME }}/spring-boot-service:${COMMIT_SHA}"
          echo "üì¶ Full image name: ${IMAGE_NAME}"

          echo "üöÄ Deploying Spring Boot app with image: ${IMAGE_NAME}"
          
          echo "üîÑ Checking deployment status..."
          
          # First check if deployment exists
          if ! oc get dc/spring-boot-app >/dev/null 2>&1; then
            echo "üÜï Creating new Spring Boot deployment..."
            cat openshift/spring-boot-deployment.yaml | sed "s|saga99/spring-boot-service:latest|${IMAGE_NAME}|g" | oc apply -f -
            echo "‚è≥ Waiting for deployment to be created..."
            sleep 5
          fi
          
          # Get current deployment status
          echo "üìã Current deployment status:"
          oc get dc/spring-boot-app
          
          # Check for in-progress rollouts
          ROLLOUT_STATUS=$(oc rollout status dc/spring-boot-app --watch=false 2>/dev/null || true)
          if [[ $ROLLOUT_STATUS == *"in progress"* ]]; then
            echo "‚è≥ Found in-progress rollout, waiting for it to complete..."
            if ! oc rollout status dc/spring-boot-app --timeout=60s; then
              echo "‚ùå Previous rollout stuck, gathering information..."
              echo "üìã Deployment events:"
              oc get events --sort-by='.lastTimestamp' | grep spring-boot-app | tail -n 5
              echo "üìã Pod status:"
              oc get pods -l deploymentconfig=spring-boot-app
              echo "‚ùå Cancelling stuck rollout..."
              oc rollout cancel dc/spring-boot-app || true
              sleep 5
            fi
          fi
          
          echo "üîÑ Updating deployment configuration..."
          # Update the image and add resource limits
          echo "üöÄ Updating container image and configuration"
          oc patch dc/spring-boot-app -p "{\"spec\":{\"template\":{\"spec\":{\"containers\":[{\"name\":\"spring-boot-app\",\"image\":\"${IMAGE_NAME}\",\"resources\":{\"limits\":{\"cpu\":\"500m\",\"memory\":\"512Mi\"},\"requests\":{\"cpu\":\"200m\",\"memory\":\"256Mi\"}},\"readinessProbe\":{\"httpGet\":{\"path\":\"/actuator/health\",\"port\":8081},\"initialDelaySeconds\":30,\"periodSeconds\":10,\"timeoutSeconds\":5},\"livenessProbe\":{\"httpGet\":{\"path\":\"/actuator/health\",\"port\":8081},\"initialDelaySeconds\":60,\"periodSeconds\":20}}]}}}}"
          
          # Then update environment variables
          echo "üîß Setting environment variables..."
          oc set env dc/spring-boot-app \
            SPRING_DATASOURCE_URL=jdbc:mysql://mysql:3306/spring_artifacts?createDatabaseIfNotExist=true \
            SPRING_DATASOURCE_USERNAME=${{ secrets.MYSQL_USERNAME }} \
            SPRING_DATASOURCE_PASSWORD=${{ secrets.MYSQL_PASSWORD }} \
            SERVER_PORT=8081
          
          # Trigger new rollout only if needed
          CURRENT_IMAGE=$(oc get dc/spring-boot-app -o jsonpath='{.spec.template.spec.containers[0].image}')
          if [ "$CURRENT_IMAGE" != "$IMAGE_NAME" ]; then
            echo "üîÑ Starting new rollout..."
            oc rollout latest dc/spring-boot-app
          else
            echo "‚úÖ Image is already up to date"
          fi
          
          # Wait for rollout with better error handling
          echo "‚è≥ Waiting for deployment to be ready..."
          
          # Show current pods before rollout
          echo "üìä Current pods before rollout:"
          oc get pods -l deploymentconfig=spring-boot-app --sort-by=.metadata.creationTimestamp
          
          # Start monitoring the rollout
          echo "üîÑ Starting rollout monitoring..."
          if ! oc rollout status dc/spring-boot-app --timeout=300s; then
            echo "‚ùå Deployment failed. Gathering debug information..."
            
            echo "üìã Events in the last 5 minutes:"
            oc get events --sort-by='.lastTimestamp' | tail -n 20
            
            echo "üìã DeploymentConfig Status:"
            oc describe dc/spring-boot-app
            
            echo "üìã Pod Status:"
            oc get pods -l deploymentconfig=spring-boot-app
            
            # Show pod logs if any exist
            FAILED_POD=$(oc get pods -l deploymentconfig=spring-boot-app --sort-by=.metadata.creationTimestamp -o name | tail -n1)
            if [ ! -z "$FAILED_POD" ]; then
            # Get the actual pod name without the prefix
            POD_NAME=$(echo $FAILED_POD | sed 's|pod/||')
            echo "üìã Pod Startup Analysis for $POD_NAME"
            
            echo "1. Pod Description:"
            oc describe pod $POD_NAME
            
            echo "2. Previous Pod Logs (if any):"
            oc logs $POD_NAME --previous || echo "No previous logs available"
            
            echo "3. Current Pod Logs:"
            oc logs $POD_NAME || echo "No current logs available"
            
            echo "4. Container Status:"
            oc get pod $POD_NAME -o jsonpath='{.status.containerStatuses[0].state}{"\n"}' || echo "Could not get container status"
            
            echo "5. Last State (if restarted):"
            oc get pod $POD_NAME -o jsonpath='{.status.containerStatuses[0].lastState}{"\n"}' || echo "No last state available"
            
            echo "6. MySQL Status Check:"
            echo "MySQL Service:"
            oc get service mysql
            echo "MySQL Pod:"
            oc get pods -l app=mysql
            
            echo "7. Application Checks:"
            if oc get pod $POD_NAME | grep -q "Running"; then
              echo "Testing Spring Boot Application..."
              echo "a) Environment Variables:"
              oc exec $POD_NAME -- env | grep -i "SPRING\|MYSQL\|DATABASE" || echo "No relevant environment variables found"
              
              echo "b) Application Properties:"
              oc exec $POD_NAME -- cat /app/BOOT-INF/classes/application.yml || echo "Could not read application.yml"
              
              echo "c) MySQL Connection:"
              oc exec $POD_NAME -- curl -v mysql:3306 || echo "MySQL connection failed"
              
              echo "d) Health Check:"
              oc exec $POD_NAME -- curl -v localhost:8081/actuator/health || echo "Health check failed"
            else
              echo "Pod not in Running state - skipping application checks"
            fi
            
            echo "8. Recent Events for this Pod:"
            oc get events --field-selector involvedObject.name=$POD_NAME --sort-by='.lastTimestamp' | tail -n 10
            fi
            
            exit 1
          fi
          
          # Show final pod status and detailed logs
          echo "üìä Final pod status:"
          oc get pods -l deploymentconfig=spring-boot-app --sort-by=.metadata.creationTimestamp
          
          # Get the latest pod
          LATEST_POD=$(oc get pods -l deploymentconfig=spring-boot-app --sort-by=.metadata.creationTimestamp -o name | tail -n1)
          if [ ! -z "$LATEST_POD" ]; then
            echo "üìã Detailed Pod Description:"
            oc describe $LATEST_POD
            
            echo "üìã Full Pod Logs (with previous if available):"
            oc logs $LATEST_POD --previous || echo "No previous logs available"
            echo "--- Current Logs ---"
            oc logs $LATEST_POD || echo "No current logs available"
            
            echo "üìã Environment Variables:"
            oc exec $LATEST_POD -- env || echo "Could not get environment variables"
            
            echo "üìã Application Health Check:"
            echo "1. Spring Boot Status:"
            oc exec $LATEST_POD -- curl -s http://localhost:8081/actuator/health || echo "Health check endpoint not accessible"
            
            echo "2. Database Connectivity:"
            oc exec $LATEST_POD -- curl -s http://localhost:8081/actuator/health/db || echo "Database health check not accessible"
            
            echo "3. Application Logs:"
            oc logs $LATEST_POD --tail=50
            
            echo "4. Environment Check:"
            oc exec $LATEST_POD -- env | grep -E "SPRING|MYSQL|DATABASE|PORT"
            
            echo "5. MySQL Connection Test:"
            MYSQL_POD=$(oc get pods -l app=mysql -o name | head -n1)
            if [ ! -z "$MYSQL_POD" ]; then
              echo "Testing MySQL Connection..."
              oc exec $MYSQL_POD -- mysql \
                -h127.0.0.1 \
                -u${{ secrets.MYSQL_USERNAME }} \
                -p${{ secrets.MYSQL_PASSWORD }} \
                -e "SELECT DATABASE(), USER(), VERSION();" spring_artifacts || echo "Could not connect to MySQL"
            fi
            
            echo "6. Resource Usage:"
            echo "Pod Resources:"
            POD_NAME_ONLY=$(echo $LATEST_POD | sed 's|pod/||')
            # Use --use-protocol-buffers flag to avoid the warning
            oc adm top pod $POD_NAME_ONLY --use-protocol-buffers || echo "Resource metrics not available"
            echo "Memory Usage:"
            oc exec $POD_NAME_ONLY -- free -h || echo "Memory info not available"
            echo "Disk Usage:"
            oc exec $POD_NAME_ONLY -- df -h || echo "Disk info not available"
          fi
            
            # Check for any failed pods
            FAILED_PODS=$(oc get pods -l deploymentconfig=spring-boot-app --field-selector status.phase!=Running -o name)
            if [ ! -z "$FAILED_PODS" ]; then
              echo "üìã Checking failed pods..."
              for pod in $FAILED_PODS; do
                POD_NAME_ONLY=$(echo $pod | sed 's|pod/||')
                echo "=== Logs from $POD_NAME_ONLY ==="
                oc logs $POD_NAME_ONLY --previous || oc logs $POD_NAME_ONLY || echo "No logs available"
                echo "=== Pod Description ==="
                oc describe pod/$POD_NAME_ONLY
              done
            fi
            
            # Only exit with error if we found actual problems
            if oc get pod $POD_NAME_ONLY | grep -q "CrashLoopBackOff\|Error\|Failed"; then
              echo "‚ùå Pod is in failed state"
              exit 1
            fi
          
          echo "‚úÖ Deployment successfully rolled out"
          
          echo "üîß Updating deployment configuration..."
          # Update environment variables
          oc set env dc/spring-boot-app \
            SPRING_DATASOURCE_URL=jdbc:mysql://mysql:3306/spring_artifacts?createDatabaseIfNotExist=true \
            SPRING_DATASOURCE_USERNAME=${{ secrets.MYSQL_USERNAME }} \
            SPRING_DATASOURCE_PASSWORD=${{ secrets.MYSQL_PASSWORD }} \
            SERVER_PORT=8081
          
          # Update image if needed
          oc set image dc/spring-boot-app spring-boot-app=${IMAGE_NAME} --record=true
          
          echo "üîÑ Triggering new deployment..."
          oc rollout latest dc/spring-boot-app || {
            if oc get dc/spring-boot-app -o jsonpath='{.status.conditions[?(@.type=="Progressing")].status}' | grep -q "True"; then
              echo "‚ÑπÔ∏è Deployment already in progress, continuing..."
            else
              echo "‚ùå Failed to trigger deployment. Checking status..."
              oc get dc/spring-boot-app
              oc describe dc/spring-boot-app
              exit 1
            fi
          }

      - name: Wait for Rollout
        run: |
          echo "‚è≥ Waiting for rollout to complete..."
          oc rollout status dc/spring-boot-app --timeout=600s

          echo "üîç Verifying deployment..."
          # Wait for new pods to be created
          sleep 10
          
          echo "üìä Checking pod status..."
          POD_STATUS=$(oc get pods -l deploymentconfig=spring-boot-app)
          echo "$POD_STATUS"
          
          if [ -z "$POD_STATUS" ]; then
            echo "‚ùå No pods found. Checking deployment config..."
            oc get dc/spring-boot-app -o yaml
            
            echo "üìã Checking events..."
            oc get events --sort-by='.lastTimestamp' | tail -n 20
            
            echo "üîÑ Forcing new deployment..."
            oc rollout latest dc/spring-boot-app
            sleep 10
          fi
          
          # Get the latest pod
          LATEST_POD=$(oc get pods -l deploymentconfig=spring-boot-app --sort-by=.metadata.creationTimestamp -o name | tail -n1)
          
          if [ -z "$LATEST_POD" ]; then
            echo "‚ùå Still no pods created. Deployment failed."
            exit 1
          fi
          
          echo "‚è≥ Waiting for pod to be ready..."
          if ! oc wait --for=condition=ready pod ${LATEST_POD#pod/} --timeout=300s; then
            echo "‚ùå Pod failed to become ready. Checking logs..."
            oc logs ${LATEST_POD#pod/}
            echo "üìã Pod description:"
            oc describe ${LATEST_POD}
            exit 1
          fi
          
          echo "‚úÖ Pod is ready. Checking application health..."
          sleep 10
          
          # Verify application is responding
          if ! oc exec ${LATEST_POD#pod/} -- curl -s http://localhost:8081/actuator/health; then
            echo "‚ùå Application health check failed"
            echo "üìã Application logs:"
            oc logs ${LATEST_POD#pod/}
            exit 1
          fi
          
          echo "‚úÖ Application is healthy"

      - name: Verify Deployment
        run: |
          echo "üîç Getting route information..."
          oc get route spring-boot-route
          
          echo "üìã Verifying route details..."
          # Get complete route configuration
          echo "Route Configuration:"
          oc get route spring-boot-route -o yaml
          
          # Get route details with proper error handling
          echo "Getting route host..."
          ROUTE_HOST=$(oc get route spring-boot-route -o jsonpath='{.spec.host}')
          
          echo "Getting route port..."
          ROUTE_PORT=$(oc get route spring-boot-route -o jsonpath='{.spec.port.targetPort}')
          
          # Optional fields - use default values if not present
          echo "Checking optional route configurations..."
          ROUTE_PATH=$(oc get route spring-boot-route -o jsonpath='{.spec.path}' 2>/dev/null || echo "/")
          ROUTE_TLS=$(oc get route spring-boot-route -o jsonpath='{.spec.tls}' 2>/dev/null || echo "")
          
          # Get service details
          echo "Getting service details..."
          SERVICE_NAME=$(oc get route spring-boot-route -o jsonpath='{.spec.to.name}')
          SERVICE_PORT=$(oc get service $SERVICE_NAME -o jsonpath='{.spec.ports[0].port}' 2>/dev/null || echo "8081")
          
          # Check actual route configuration
          echo "Checking route protocol configuration..."
          if oc get route spring-boot-route -o yaml | grep -q "tls:"; then
            echo "üîí TLS configuration found, using HTTPS"
            PROTOCOL="https"
          else
            echo "üîì Route is configured for HTTP"
            PROTOCOL="http"
          fi
          
          # Build and validate URL
          echo "Building route URL..."
          FULL_URL="${PROTOCOL}://${ROUTE_HOST}"
          if [ "$ROUTE_PATH" != "/" ]; then
            echo "Adding path: ${ROUTE_PATH}"
            FULL_URL="${FULL_URL}${ROUTE_PATH}"
          fi
          
          # Verify URL components
          echo "üîç Route Details:"
          echo "Protocol: ${PROTOCOL}"
          echo "Host: ${ROUTE_HOST}"
          echo "Path: ${ROUTE_PATH}"
          echo "Port: ${ROUTE_PORT}"
          echo "Service: ${SERVICE_NAME}"
          echo "Service Port: ${SERVICE_PORT}"
          echo "Full URL: ${FULL_URL}"
          
          echo "üåê Application URL: ${FULL_URL}"
          echo "üîí Protocol: ${PROTOCOL}"
          echo "üåç Host: ${ROUTE_HOST}"
          echo "üìç Path: ${ROUTE_PATH:-/}"
          echo "üîå Port: ${ROUTE_PORT:-8081}"
          
          # Get pod information
          POD_NAME=$(oc get pods -l app=spring-boot-app -o jsonpath='{.items[0].metadata.name}')
          MYSQL_POD=$(oc get pods -l app=mysql -o jsonpath='{.items[0].metadata.name}')
          
          echo "üì¶ Running Pod: ${POD_NAME}"
          echo "üóÑÔ∏è MySQL Pod: ${MYSQL_POD}"
          
          # Store values for later use
          echo "ROUTE_URL=${FULL_URL}" >> $GITHUB_ENV
          echo "APP_POD=${POD_NAME}" >> $GITHUB_ENV
          echo "MYSQL_POD=${MYSQL_POD}" >> $GITHUB_ENV
          
          # Verify route is accessible
          echo "üîç Testing route accessibility..."
          if curl -k -s -o /dev/null -w "%{http_code}" "${FULL_URL}/actuator/health"; then
            echo "‚úÖ Route is accessible"
          else
            echo "‚ùå Route is not accessible. Checking route configuration..."
            oc describe route spring-boot-route
            exit 1
          fi
          
          echo "üìã Application logs (last 10 lines):"
          oc logs ${POD_NAME} --tail=10
          
          echo "üîç Testing health endpoint..."
          if oc exec ${POD_NAME} -- curl -s http://localhost:8081/actuator/health > /dev/null; then
            echo "‚úÖ Health check passed"
            echo "HEALTH_STATUS=SUCCESS" >> $GITHUB_ENV
          else
            echo "‚ùå Health check failed"
            echo "HEALTH_STATUS=FAILED" >> $GITHUB_ENV
            exit 1
          fi
          
          echo "üîç Testing application response..."
          RESPONSE_CODE=$(oc exec ${POD_NAME} -- curl -s -o /dev/null -w "%{http_code}" http://localhost:8081/actuator/health || echo "000")
          if [ "$RESPONSE_CODE" = "200" ]; then
            echo "‚úÖ Application is responding correctly"
            echo "RESPONSE_CODE=200" >> $GITHUB_ENV
          else
            echo "‚ùå Application not responding properly (HTTP $RESPONSE_CODE)"
            echo "RESPONSE_CODE=$RESPONSE_CODE" >> $GITHUB_ENV
            exit 1
          fi

      - name: Deployment Status
        run: |
          echo "üéâ DEPLOYMENT SUMMARY"
          echo "===================="
          oc get pods -l app=spring-boot-app
          echo ""
          oc get route spring-boot-route
          echo ""
          echo "‚úÖ CD Pipeline Completed Successfully!"

  notify:
    name: Send Discord Notification
    runs-on: ubuntu-latest
    needs: deploy-to-openshift
    if: always()
    steps:
      - name: Install OpenShift CLI
        run: |
          echo "üì• Installing OpenShift CLI..."
          curl -L https://mirror.openshift.com/pub/openshift-v4/clients/oc/latest/linux/oc.tar.gz -o oc.tar.gz
          tar -xzf oc.tar.gz
          sudo mv oc /usr/local/bin/
          sudo chmod +x /usr/local/bin/oc
          echo "‚úÖ OpenShift CLI installed"

      - name: Log in to OpenShift
        uses: redhat-actions/oc-login@v1
        with:
          openshift_server_url: ${{ secrets.OPENSHIFT_SERVER_URL }}
          openshift_token: ${{ secrets.OPENSHIFT_TOKEN }}
          namespace: ${{ secrets.OPENSHIFT_PROJECT }}

      - name: Send Discord Notification
        run: |
          if [ "${{ needs.deploy-to-openshift.result }}" == "success" ]; then
            STATUS="‚úÖ Success"
            COLOR=3066993
            
            # Get route information safely using grep/awk
            echo "üîç Getting route details..."
            
            # Get route configuration
            ROUTE_CONFIG=$(oc get route spring-boot-route -o yaml)
            echo "Route Configuration:"
            echo "$ROUTE_CONFIG"
            
            # Extract host using grep/awk
            ROUTE_HOST=$(echo "$ROUTE_CONFIG" | grep "^  host:" | awk '{print $2}')
            if [ -z "$ROUTE_HOST" ]; then
              echo "‚ö†Ô∏è Could not get route host"
              ROUTE_HOST="N/A"
            fi
            
            # Check if route has TLS configuration
            if echo "$ROUTE_CONFIG" | grep -q "tls:"; then
              echo "üîí TLS is configured, using HTTPS"
              PROTOCOL="https"
            else
              echo "üîì Route is configured for HTTP"
              PROTOCOL="http"
            fi
            
            # Build URL if we have a valid host
            if [ "$ROUTE_HOST" != "N/A" ]; then
              FULL_URL="${PROTOCOL}://${ROUTE_HOST}"
              echo "üåê Constructed URL: ${FULL_URL}"
            else
              FULL_URL="N/A"
              echo "‚ö†Ô∏è Could not construct URL"
            fi
            
            # Verify route is accessible
            echo "üîç Verifying route accessibility..."
            ROUTE_STATUS=$(curl -k -s -o /dev/null -w "%{http_code}" "${FULL_URL}/actuator/health" || echo "Failed")
            if [ "$ROUTE_STATUS" = "200" ]; then
              echo "‚úÖ Route is accessible"
            else
              echo "‚ö†Ô∏è Route accessibility check returned: $ROUTE_STATUS"
            fi
            
            # Get pod status and metrics safely
            echo "üîç Getting deployment metrics..."
            
            # Get pod information using grep/awk for reliability
            POD_INFO=$(oc get pods -l app=spring-boot-app --sort-by=.metadata.creationTimestamp)
            POD_NAME=$(echo "$POD_INFO" | tail -1 | awk '{print $1}')
            
            if [ ! -z "$POD_NAME" ]; then
              echo "üìä Getting metrics for pod: $POD_NAME"
              
              # Get pod status
              POD_STATUS=$(oc get pod $POD_NAME -o yaml | grep "phase:" | awk '{print $2}')
              if [ -z "$POD_STATUS" ]; then
                POD_STATUS="Unknown"
              fi
              
              # Get resource usage
              echo "Getting resource usage..."
              TOP_OUTPUT=$(oc adm top pod $POD_NAME --use-protocol-buffers 2>/dev/null || echo "")
              if [ ! -z "$TOP_OUTPUT" ]; then
                CPU_USAGE=$(echo "$TOP_OUTPUT" | tail -1 | awk '{print $2}')
                MEMORY_USAGE=$(echo "$TOP_OUTPUT" | tail -1 | awk '{print $3}')
              else
                CPU_USAGE="N/A"
                MEMORY_USAGE="N/A"
              fi
              
              # Get health status if pod is running
              if [ "$POD_STATUS" = "Running" ]; then
                echo "Checking health status..."
                HEALTH_CHECK=$(oc exec $POD_NAME -- curl -s http://localhost:8081/actuator/health || echo '{"status":"N/A"}')
                HEALTH_STATUS=$(echo "$HEALTH_CHECK" | grep -o '"status":"[^"]*"' | cut -d'"' -f4 || echo "N/A")
                RESPONSE_CODE=$(oc exec $POD_NAME -- curl -s -o /dev/null -w "%{http_code}" http://localhost:8081/actuator/health || echo "N/A")
              else
                HEALTH_STATUS="Not Ready"
                RESPONSE_CODE="N/A"
              fi
            else
              echo "‚ö†Ô∏è No pods found"
              POD_STATUS="No Pods"
              CPU_USAGE="N/A"
              MEMORY_USAGE="N/A"
              HEALTH_STATUS="N/A"
              RESPONSE_CODE="N/A"
            fi
          else
            STATUS="‚ùå Failed"
            COLOR=15158332
            POD_STATUS="Failed"
            CPU_USAGE="N/A"
            MEMORY_USAGE="N/A"
            HEALTH_STATUS="Failed"
            RESPONSE_CODE="N/A"
            FULL_URL="N/A"
          fi
          
          # Send to Discord with enhanced information
          curl -H "Content-Type: application/json" \
               -X POST \
               -d '{
                 "username": "OpenShift CD Bot",
                 "embeds": [{
                   "title": "'"Deployment: $STATUS"'",
                   "description": "**Repository:** [${{ github.repository }}](${{ github.server_url }}/${{ github.repository }})\n**Branch:** `${{ github.ref_name }}`\n**Commit:** `${{ github.sha }}`\n\n**üåê Application URL:** `'"$FULL_URL"'`\n**üè• Health Status:** `'"$HEALTH_STATUS"'`\n**üîÑ Response Code:** `'"$RESPONSE_CODE"'`\n\n**üìä Pod Status:** `'"$POD_STATUS"'`\n**üíª CPU Usage:** `'"$CPU_USAGE"'`\n**üíæ Memory Usage:** `'"$MEMORY_USAGE"'`\n\n**üìù Deployment Notes:**\n‚Ä¢ Spring Boot application is running on port 8081\n‚Ä¢ MySQL database is connected and migrations are complete\n‚Ä¢ Health checks are passing\n‚Ä¢ Monitoring endpoints are available at /actuator/*\n\n**üîó Quick Links:**\n‚Ä¢ Health Check: `'"$FULL_URL"'/actuator/health`\n‚Ä¢ Metrics: `'"$FULL_URL"'/actuator/metrics`\n‚Ä¢ Info: `'"$FULL_URL"'/actuator/info`",
                   "color": '"$COLOR"',
                   "footer": {
                     "text": "Deployment completed at '"$(date -u "+%Y-%m-%d %H:%M:%S UTC")"'"
                   }
                 }]
               }' \
               "${{ secrets.DISCORD_WEBHOOK_URL }}"
          
  notify-start:
    name: Notify Deployment Start
    runs-on: ubuntu-latest
    if: always()
    steps:
      - name: Send Start Notification
        run: |
          curl -H "Content-Type: application/json" \
               -X POST \
               -d '{
                 "username": "OpenShift CD Bot",
                 "embeds": [
                   {
                    "title": "üöÄ Deployment Started",
                    "description": "**Repository:** [${{ github.repository }}](${{ github.server_url }}/${{ github.repository }})\n**Branch:** `${{ github.ref_name }}`\n**Commit:** `${{ github.sha }}`\n\n**üîÑ Triggered by:** CI Pipeline Completion\n**üéØ Target Environment:** Production\n**üìç Namespace:** ${{ secrets.OPENSHIFT_PROJECT }}\n\n**üìù Deployment Plan:**\n‚Ä¢ Verify/create MySQL secrets\n‚Ä¢ Check/deploy MySQL database\n‚Ä¢ Deploy Spring Boot application\n‚Ä¢ Run database migrations\n‚Ä¢ Configure routes and services\n‚Ä¢ Verify health and connectivity",
                     "color": 16776960,
                    "timestamp": "'$(date -u +"%Y-%m-%dT%H:%M:%SZ")'",
                    "footer": {
                      "text": "Estimated completion time: 3-5 minutes"
                    }
                   }
                 ]
               }' \
               "${{ secrets.DISCORD_WEBHOOK_URL }}"

# OpenShift Cluster
# ‚îÇ
# ‚îú‚îÄ‚îÄ Namespace: your-project
# ‚îÇ   ‚îú‚îÄ‚îÄ Secret: mysql-root-secret
# ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ MYSQL_ROOT_PASSWORD: "actual-password-here"
# ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ MYSQL_DATABASE: "spring_artifacts"
# ‚îÇ   ‚îÇ
# ‚îÇ   ‚îî‚îÄ‚îÄ Secret: mysql-secret
# ‚îÇ       ‚îú‚îÄ‚îÄ SPRING_DATASOURCE_URL: "jdbc:mysql://mysql-service:3306/spring_artifacts..."
# ‚îÇ       ‚îú‚îÄ‚îÄ SPRING_DATASOURCE_USERNAME: "app-username"
# ‚îÇ       ‚îú‚îÄ‚îÄ SPRING_DATASOURCE_PASSWORD: "app-password"
# ‚îÇ       ‚îî‚îÄ‚îÄ SERVER_PORT: "8081"