name: Spring Boot CD to OpenShift





# Watches your CI pipeline named "Spring Boot CI"

# Triggers automatically when CI completes successfully on main branch

# This creates the CI ‚Üí CD chain
on:
  workflow_run:
    workflows: ["Spring Boot CI"]
    types:
      - completed
    branches:
      - main

jobs:
  deploy-to-openshift:
    name: Deploy to OpenShift
    runs-on: ubuntu-latest
    environment: production

# Gets your OpenShift YAML files from repository

    steps:
      - name: Checkout code
        uses: actions/checkout@v4


# Authenticates with OpenShift cluster using secrets
      - name: Log in to OpenShift
        uses: redhat-actions/oc-login@v1
        with:
          openshift_server_url: ${{ secrets.OPENSHIFT_SERVER_URL }}
          openshift_token: ${{ secrets.OPENSHIFT_TOKEN }}
          namespace: ${{ secrets.OPENSHIFT_PROJECT }}

      # --- 1. Create Secrets for Both MySQL and Spring Boot ---

# OpenShift Cluster
# ‚îÇ
# ‚îú‚îÄ‚îÄ Namespace: your-project
# ‚îÇ   ‚îú‚îÄ‚îÄ Secret: mysql-root-secret
# ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ MYSQL_ROOT_PASSWORD: "actual-password-here"
# ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ MYSQL_DATABASE: "spring_artifacts"
# ‚îÇ   ‚îÇ
# ‚îÇ   ‚îî‚îÄ‚îÄ Secret: mysql-secret
# ‚îÇ       ‚îú‚îÄ‚îÄ SPRING_DATASOURCE_URL: "jdbc:mysql://mysql-service:3306/spring_artifacts..."
# ‚îÇ       ‚îú‚îÄ‚îÄ SPRING_DATASOURCE_USERNAME: "app-username"
# ‚îÇ       ‚îú‚îÄ‚îÄ SPRING_DATASOURCE_PASSWORD: "app-password"
# ‚îÇ       ‚îî‚îÄ‚îÄ SERVER_PORT: "8081"






      - name: Create MySQL Secrets
        run: |
          # Secret for MySQL deployment itself
          # Stores MySQL root password and database name for MySQL container in mysql-root-secret
          if ! oc get secret mysql-root-secret >/dev/null 2>&1; then
            echo "üîê Creating MySQL root secret..."
            oc create secret generic mysql-root-secret \
              --from-literal=MYSQL_ROOT_PASSWORD=${{ secrets.MYSQL_ROOT_PASSWORD }} \
              --from-literal=MYSQL_DATABASE=spring_artifacts
          else
            echo "‚úÖ MySQL root secret already exists"
          fi

          # Secret for Spring Boot application - UPDATED for Spring properties
          # Stores Spring Boot database connection details and server port
          if ! oc get secret mysql-secret >/dev/null 2>&1; then
            echo "üîê Creating MySQL application secret..."
            oc create secret generic mysql-secret \
              --from-literal=SPRING_DATASOURCE_URL=jdbc:mysql://mysql:3306/spring_artifacts?createDatabaseIfNotExist=true \
              --from-literal=SPRING_DATASOURCE_USERNAME=${{ secrets.MYSQL_USERNAME }} \
              --from-literal=SPRING_DATASOURCE_PASSWORD=${{ secrets.MYSQL_PASSWORD }} \
              --from-literal=SERVER_PORT=8081
          else
            echo "‚úÖ MySQL application secret already exists"
          fi

      # --- 2. Bootstrap Infrastructure ---


#       Creates MySQL Persistent Volume Claim (storage)

# Deploys MySQL container

# Creates MySQL service (network access)

# Waits for MySQL to be fully ready
      - name: Bootstrap Environment
        run: |
          # Deploy MySQL if not exists
          if ! oc get deployment/mysql >/dev/null 2>&1; then
            echo "üîß Deploying MySQL database..."
            oc apply -f openshift/mysql/mysql-pvc.yaml
            oc apply -f openshift/mysql/mysql-deployment.yaml
            oc apply -f openshift/mysql/mysql-service.yaml
            
            echo "‚è≥ Waiting for MySQL to be ready..."
            oc wait --for=condition=ready pod -l app=mysql --timeout=300s
            echo "‚úÖ MySQL is ready"
          else
            echo "‚úÖ MySQL already deployed"
          fi

          # Create Spring Boot service and route if not exists
          if ! oc get route spring-boot-route >/dev/null 2>&1; then
            echo "üîß Creating Spring Boot services..."
            oc apply -f openshift/spring-boot-service.yaml
            oc apply -f openshift/spring-boot-route.yaml
            echo "‚úÖ Spring Boot services created"
          else
            echo "‚úÖ Spring Boot services already exist"
          fi

      # --- 3. Deploy Spring Boot App with Specific Image ---
      - name: Deploy Spring Boot Application
        run: |
          COMMIT_SHA="${{ github.event.workflow_run.head_sha }}"
          SHORT_SHA="${COMMIT_SHA:0:7}"
          IMAGE_NAME="saga99/spring-boot-service:${SHORT_SHA}"

          echo "üöÄ Deploying Spring Boot app with image: ${IMAGE_NAME}"
          
          # Set environment variables from secrets
          echo "üîß Setting environment variables from secrets..."
          oc set env dc/spring-boot-app \
            SPRING_DATASOURCE_URL=jdbc:mysql://mysql:3306/spring_artifacts?createDatabaseIfNotExist=true \
            SPRING_DATASOURCE_USERNAME=${{ secrets.MYSQL_USERNAME }} \
            SPRING_DATASOURCE_PASSWORD=${{ secrets.MYSQL_PASSWORD }} \
            SERVER_PORT=8081
          
          # Check if deployment exists, create or update accordingly
          if oc get dc/spring-boot-app >/dev/null 2>&1; then
            echo "üîÑ Updating existing deployment..."
            oc set image dc/spring-boot-app spring-boot-app=${IMAGE_NAME} --record=true
            oc rollout latest dc/spring-boot-app
          else
            echo "üÜï Creating new deployment..."
            # Create deployment with the specific image
            cat openshift/spring-boot-deployment.yaml | sed "s|saga99/spring-boot-service:latest|${IMAGE_NAME}|g" | oc apply -f -
          fi

      # --- 4. Wait for Rollout with Health Checks ---
      - name: Wait for Rollout
        run: |
          echo "‚è≥ Waiting for rollout to complete..."
          oc rollout status dc/spring-boot-app --timeout=600s
          
          # Wait for pod to be fully ready (not just running)
          echo "üîç Waiting for application to be fully ready..."
          oc wait --for=condition=ready pod -l app=spring-boot-app --timeout=300s

      # --- 5. Comprehensive Verification ---
      - name: Verify Deployment
        run: |
          ROUTE_URL=$(oc get route spring-boot-route -o jsonpath='{.spec.host}')
          POD_NAME=$(oc get pods -l app=spring-boot-app -o jsonpath='{.items[0].metadata.name}')
          MYSQL_POD=$(oc get pods -l app=mysql -o jsonpath='{.items[0].metadata.name}')
          
          echo "üåê Application URL: https://${ROUTE_URL}"
          echo "üì¶ Running Pod: ${POD_NAME}"
          echo "üóÑÔ∏è MySQL Pod: ${MYSQL_POD}"
          
          # Store values for notification
          echo "ROUTE_URL=https://${ROUTE_URL}" >> $GITHUB_ENV
          echo "APP_POD=${POD_NAME}" >> $GITHUB_ENV
          echo "MYSQL_POD=${MYSQL_POD}" >> $GITHUB_ENV
          
          # Check application logs
          echo "üìã Application logs (last 10 lines):"
          oc logs ${POD_NAME} --tail=10
          
          # Test health endpoint
          echo "üîç Testing health endpoint..."
          if oc exec ${POD_NAME} -- curl -s http://localhost:8081/actuator/health > /dev/null; then
            echo "‚úÖ Health check passed"
            echo "HEALTH_STATUS=SUCCESS" >> $GITHUB_ENV
          else
            echo "‚ùå Health check failed"
            echo "HEALTH_STATUS=FAILED" >> $GITHUB_ENV
            exit 1
          fi
          
          # Test if application responds
          echo "üîç Testing application response..."
          RESPONSE_CODE=$(oc exec ${POD_NAME} -- curl -s -o /dev/null -w "%{http_code}" http://localhost:8081/actuator/health || echo "000")
          if [ "$RESPONSE_CODE" = "200" ]; then
            echo "‚úÖ Application is responding correctly"
            echo "RESPONSE_CODE=200" >> $GITHUB_ENV
          else
            echo "‚ùå Application not responding properly (HTTP $RESPONSE_CODE)"
            echo "RESPONSE_CODE=$RESPONSE_CODE" >> $GITHUB_ENV
            exit 1
          fi

      # --- 6. Final Status Report ---
      - name: Deployment Status
        run: |
          echo "üéâ DEPLOYMENT SUMMARY"
          echo "===================="
          oc get pods -l app=spring-boot-app
          echo ""
          oc get route spring-boot-route
          echo ""
          echo "‚úÖ CD Pipeline Completed Successfully!"

  notify:
    name: Send Discord Notification
    runs-on: ubuntu-latest
    needs: deploy-to-openshift
    if: always()
    steps:
      - name: Build JSON Payload
        id: payload
        run: |
          # Determine status and color
          STATUS="SUCCESS"
          COLOR=65280  # Green
          if [ "${{ needs.deploy-to-openshift.result }}" != "success" ]; then
            STATUS="FAILURE"
            COLOR=16711680  # Red
          fi
          
          # Get additional deployment info
          ROUTE_URL="${{ env.ROUTE_URL }}"
          APP_POD="${{ env.APP_POD }}"
          MYSQL_POD="${{ env.MYSQL_POD }}"
          HEALTH_STATUS="${{ env.HEALTH_STATUS }}"
          RESPONSE_CODE="${{ env.RESPONSE_CODE }}"
          
          # Build description with all deployment details
          DESCRIPTION="**Repository:** [${{ github.repository }}](${{ github.repository }})
**Branch:** ${{ github.ref_name }}
**Commit:** ${{ github.sha }}
**Deployment Status:** $STATUS
**Health Check:** ${HEALTH_STATUS:-UNKNOWN}
**Response Code:** ${RESPONSE_CODE:-UNKNOWN}
**Workflow Run:** [View Run](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})

**üåê Application URL:** [$ROUTE_URL]($ROUTE_URL)
**üì¶ Application Pod:** ${APP_POD:-UNKNOWN}
**üóÑÔ∏è MySQL Pod:** ${MYSQL_POD:-UNKNOWN}
**üê≥ Docker Image:** saga99/spring-boot-service:${{ github.sha }}

**üìä Database Information:**
‚Ä¢ **Host:** mysql-service
‚Ä¢ **Database:** spring_artifacts
‚Ä¢ **Username:** ${{ secrets.MYSQL_USERNAME }}
‚Ä¢ **Port:** 3306

**üõ†Ô∏è OpenShift Project:** ${{ secrets.OPENSHIFT_PROJECT }}"

          jq -n \
            --arg status "$STATUS" \
            --argjson color "$COLOR" \
            --arg description "$DESCRIPTION" \
            '{
              username: "OpenShift CD Bot",
              embeds: [
                {
                  title: "üöÄ CD Deployment Status: \($status)",
                  description: $description,
                  color: $color,
                  timestamp: (now | strftime("%Y-%m-%dT%H:%M:%SZ")),
                  footer: {
                    text: "Deployed via GitHub Actions"
                  },
                  fields: [
                    {
                      name: "üìä Deployment Info",
                      value: "Status: \($status)\nHealth: '"${HEALTH_STATUS:-UNKNOWN}"'\nResponse: '"${RESPONSE_CODE:-UNKNOWN}"'",
                      inline: true
                    },
                    {
                      name: "üåê Access",
                      value: "URL: [Open Application]('"${ROUTE_URL}"')\nProject: '"${{ secrets.OPENSHIFT_PROJECT }}"'",
                      inline: true
                    }
                  ]
                }
              ]
            }' > payload.json

          # Debug: Show payload content
          echo "üìã Notification payload:"
          cat payload.json

      - name: Send Discord Notification
        run: |
          echo "üì§ Sending Discord notification..."
          curl -H "Content-Type: application/json" \
               -X POST \
               -d @payload.json \
               "${{ secrets.DISCORD_WEBHOOK_URL }}"
          
          if [ $? -eq 0 ]; then
            echo "‚úÖ Discord notification sent successfully"
          else
            echo "‚ùå Failed to send Discord notification"
            exit 1
          fi

  # Optional: Pre-deployment notification
  notify-start:
    name: Notify Deployment Start
    runs-on: ubuntu-latest
    if: always()
    steps:
      - name: Send Start Notification
        run: |
          curl -H "Content-Type: application/json" \
               -X POST \
               -d '{
                 "username": "OpenShift CD Bot",
                 "embeds": [
                   {
                     "title": "üîÑ Deployment Started",
                     "description": "**Repository:** [${{ github.repository }}](${{ github.repository }})\n**Branch:** ${{ github.ref_name }}\n**Commit:** ${{ github.sha }}\n**Triggered by:** CI Pipeline Completion\n\nDeployment to OpenShift production environment is starting...",
                     "color": 16776960,
                     "timestamp": "'$(date -u +"%Y-%m-%dT%H:%M:%SZ")'"
                   }
                 ]
               }' \
               "${{ secrets.DISCORD_WEBHOOK_URL }}"